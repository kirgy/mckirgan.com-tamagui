---
title: 'TypeScript Test Driven Development'
publishedDate: '2021-02-07T15:47:00.000Z'
articleReadTimeMinutes: 4
imageBanner: '/blog/type-script-test-driven-development/banner.png'
metaDescription: 'Test Driven Development (TDD) is a programming style known for it`s *test-first* approach, where testing, design and programming are tightly bound together, but essentially driven by rules specified in Unit Tests. TDD is widely reported to drive better software design, reduce coding errors and actually reduce development effort under agile development.'
metaKeywords: 'typescript, test driven design, TDD, Kata, Roman numerals'
metaImageFacebook: '/blog/type-script-test-driven-development/banner.png'
metaImageTwitter: '/blog/type-script-test-driven-development/banner.png'
---

_Note: The image for this article was generated by DALL-E II_

## Karate Coding

I recently completed a [Kata](<https://en.wikipedia.org/wiki/Kata_(programming)>) involving converting arabic integers - our whole number system, to Roman Numerals in TypeScript. Any regular reader will know I go by a mantra of, _when we're doing something unimportant, we should be creating learning opportunities_. So I took the opportunity to exercise a strict Test Driven Development approach.

Test Driven Development (TDD) is a programming style known for its _test-first_ approach, where testing, design and programming are tightly bound together, but essentially driven by rules specified in Unit Tests. TDD is widely reported to drive better software design, reduce coding errors and actually reduce development effort under agile development.

You can see the code for this project on my github, look for the details in the `README.md` file for how to setup. Look at the git commits to follow along with the TDD approach.

- [https://github.com/kirgy/roman-numerals](https://github.com/kirgy/roman-numerals)

## So what's TDD look like for a TypeScript application?

For this project I chose to use Jest for testing my application. Jest is a very popular Javascript testing framework, and for our purposes a simple test takes an input and asserts an expected output like this:

```typescript
test('converts decimal 1 to roman numeral I', () => {
  const result: string = convertNumerals(1)
  const expected: string = 'I'

  expect(result).toBe(expected)
})
```

Just as the test string say, given the input `1` we expect the Roman Numeral `I`;
`converts decimal 1 to roman numeral I`

This clearly explains the expected behaviour, and given spells out what is expected in terms of input to output.

## The Challenge of TDD

Test Driven Development challenges developers to not think too far ahead, and instead focus on incremental behavioural changes. A common mistake is to sit in the tests writing all possible scenarios. Where this might seem like a good idea, this sort of test driven development removes the potential for improved _software design_ from our test/code/design triade.

Instead we focus on incremental tests. This in reality likely means our first code might be poorer than where we may have started by jumping ahead, but by focusing on _incremental changes driven by incremental tests_.

## How this helped build a better application

Initially I went along the lines of a very simple approach. I knew at this point that going forward this was not going to work. This didn't matter, because we're following TDD:

```typescript
export const convertNumerals = (givenInt: number): string => {
  for (let i = 0; i < givenInt; i++) {
    romanNumeral += 'I'
  }

  return romanNumeral
}
```

This simply looped and returned `I` to the number of times of the given integer. This works for numbers 1-3. However when _behaviour changes_ for integer 4 we get result `IIIII` not the expected `IV`.

[See commit](https://github.com/kirgy/roman-numerals/commit/ed09f8404f32ebfafdb0682add82977fed505312)

This is where the [given test assertion](https://github.com/kirgy/roman-numerals/commit/3e688ce6b6fd629ec963dcfed78e3a5482b1787d) helped us determine when a code change driven by the test should take place;

```typescript
export const convertNumerals = (givenInt: number): string => {
  let romanNumeral: string = ''
  let remainValue: number = givenInt

  if (remainValue == 4) {
    romanNumeral += 'IV'
    remainValue -= 4
  }

  if (remainValue >= 5) {
    romanNumeral += 'V'
    remainValue -= 5
  }

  while (remainValue > 0) {
    romanNumeral += 'I'
    remainValue -= 1
  }

  return romanNumeral
}
```

[See commit](https://github.com/kirgy/roman-numerals/commit/d603b35205d27bfc0411b669ca14a85677cf3b9b)

This worked for numbers up to 5, but once _behaviour changed_ with number 6, this failed. Ultimately through iterations, and surprisingly to me - **very little cognitive effort** I stumbled across this solution after observing patterns in the unit tests;

```typescript
export const convertNumerals = (givenInt: number): string => {
  let romanNumeral: string = ''
  let remainValue: number = givenInt

  const intToRom: Array<intRomDef> = [
    { int: 10, rom: 'X' },
    { int: 9, rom: 'IX' },
    { int: 5, rom: 'V' },
    { int: 4, rom: 'IV' },
    { int: 1, rom: 'I' },
  ]

  intToRom.forEach((intRom) => {
    while (remainValue > intRom.int - 1) {
      romanNumeral += intRom.rom
      remainValue -= intRom.int
    }
  })

  return romanNumeral
}
```

Essentially, I kept track of a "remaining" value. Going from larger number to smallest, each time we found a Roman Numeral which fit inside the remainder, we appended it to our Roman Numeral string, and deducted it from our remainder. This is of course much more efficient than our ever growing `if statement` conditions.

[See commit](https://github.com/kirgy/roman-numerals/commit/ee87430957cbb2c404a20286dd5095f0b2f0f290)

**The point is this**; by letting _tests_ drive _application behaviour_ we improved _application design_.

## Where to go from here

This application's design uses patterns of such as `IV` as a given glyph. There is a pattern that emerges as more Roman Numerals were added, and it's evident this is not an efficient mechanism for comparing and converting. This Kata was completed in just over an hour, and achieving further efficiency wasn't drawn out in that time. I would suspect by continuing this Kata better application design would emerge from the TDD.

Want to have a go yourself? Why not checkout this website, you'll also be able to read through other people's solutions there;
[https://codingdojo.org/kata/RomanNumerals/](https://codingdojo.org/kata/RomanNumerals/)
